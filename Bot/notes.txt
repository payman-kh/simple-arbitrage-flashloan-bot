things to consider
1. chains
2. dexes
3. dex layers/versions
4. pairs
5. gas/flashloan fees


things to make dynamic
1. borrow amount
2. slippage buffer
3. minimum profit threshold
4. interval ms

Same from the gpt:
âœ… Things to Consider (static / predefined choices in code)
1. Chains â€“ Polygon, Optimism, Arbitrum, BNB, later Ethereum.
2. DEXes â€“ Uniswap, Sushiswap (and possibly others later).
3. DEX Versions â€“ e.g., Uniswap V2 vs V3.
4. Liquidity Pools / Pairs â€“ which pairs to monitor (e.g., WETH/USDC, WETH/DAI).
5. Gas Costs â€“ per chain (they differ significantly).
6. Flashloan Fees â€“ e.g., Aave charges 0.09% per loan.
7. Router & Pool Addresses â€“ different per DEX & chain.
8. Block Times / Finality Speed â€“ affects arbitrage execution reliability.
9. Arbitrage Path Type:
    - 2-point (DEX A â†’ DEX B)
    - Triangular (DEX A Pair1 â†’ Pair2 â†’ Pair3 â†’ back to Pair1).

ðŸ”„ Things to Make Dynamic (calculated in real time)
1. Borrow Amount â€“ optimal loan size for maximum profit vs slippage.
2. Slippage Buffer â€“ to prevent losses from MEV/front-running.
3. Minimum Profit Threshold â€“ must be > (gas + flashloan fee + risk margin).
4. Pool Liquidity Depth â€“ ensures you donâ€™t move the market too much.
5. Execution Gas Limit â€“ estimate & adapt depending on contract complexity.
6. Routing Logic â€“ best path across pairs and DEX versions (could shift per block).
7. Price Feed Cross-Check â€“ (optional) use Chainlink oracles to confirm no manipulation.


Optimization Point:
Each chain gets its own scanner file, even though the logic in the function is almost the same.
But this way they can all be run in parallel by calling them from the main scanner.